\documentclass[11pt,a4paper]{article}
%%%%%%%%%%%%%%%%%%%%%%%%% Credit %%%%%%%%%%%%%%%%%%%%%%%%

% template ini dibuat oleh martin.manullang@if.itera.ac.id untuk dipergunakan oleh seluruh sivitas akademik itera.

%%%%%%%%%%%%%%%%%%%%%%%%% PACKAGE starts HERE %%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}
\usepackage{caption}
% \usepackage{microtype}  % Disabled - causes font expansion errors
\captionsetup[table]{name=Tabel}
\captionsetup[figure]{name=Gambar}
\usepackage{tabulary}
\usepackage{minted}
\usepackage{amsmath}
\usepackage{fancyhdr}
% \usepackage{amssymb}
% \usepackage{amsthm}
\usepackage{placeins}
% \usepackage{amsfonts}
\usepackage{graphicx}
\usepackage[all]{xy}
\usepackage{tikz}
\usepackage{verbatim}
\usepackage[left=2cm,right=2cm,top=3cm,bottom=2.5cm]{geometry}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{multirow}
% \usepackage{psfrag}  % Disabled - not compatible with pdflatex
\usepackage[T1]{fontenc}
\usepackage[scaled]{beramono}
% Enable inserting code into the document
\usepackage{listings}
\usepackage{xcolor} 
\usepackage[T1]{fontenc}
\usepackage[scaled]{beramono}
% Fix for Unicode drawing box characters
\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}
\newunicodechar{│}{|}
\newunicodechar{├}{|}
\newunicodechar{─}{-}
% Enable inserting code into the document
% custom color & style for listing
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{LightGray}{gray}{0.9}
\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{green},
	keywordstyle=\color{codegreen},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}
\lstset{style=mystyle}
\renewcommand{\lstlistingname}{Kode}
%%%%%%%%%%%%%%%%%%%%%%%%% PACKAGE ends HERE %%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%% Data Diri %%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\studentone}{\textbf{Aziz Kurniawan (122140097)}}
\newcommand{\studenttwo}{\textbf{Muhammad Yusuf (122140193)}}
\newcommand{\studentthree}{\textbf{Harisya Miranti  (122140049)}}
\newcommand{\course}{\textbf{Sistem Teknologi Multimedia (IF25-40305 )}}
\newcommand{\assignment}{\textbf{Shadow Boxing}}
\newcommand{\lecturerA}{\textbf{Martin Clinton Tosima Manullang, Ph.D.}}
\newcommand{\tanggal}{\textbf{\today}}

%%%%%%%%%%%%%%%%%%% using theorem style %%%%%%%%%%%%%%%%%%%%
\newtheorem{thm}{Theorem}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{defn}[thm]{Definition}
\newtheorem{exa}[thm]{Example}
\newtheorem{rem}[thm]{Remark}
\newtheorem{coro}[thm]{Corollary}
\newtheorem{quest}{Question}[section]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{lipsum}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{Aziz Kurniawan (122140097) - Muhammad Yusuf (122140193) - Harisya Miranti (122140049)}
\rhead{\thepage}
\cfoot{\textbf{Sistem/Teknologi Multimedia - IF ITERA}}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

%%%%%%%%%%%%%%  Shortcut for usual set of numbers  %%%%%%%%%%%

\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\setlength\headheight{14pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%555
\begin{document}
\thispagestyle{empty}
\begin{center}
    \includegraphics[scale=0.15]{Figure/ifitera-header.png}
    \vspace{0.1cm}
\end{center}

\noindent
\rule{\textwidth}{1pt} \\[0.1cm] % Garis atas tebal
\noindent
\begin{tabular}{@{}p{3.5cm} p{0.2cm} p{12cm}@{}}
    Nama           & : & \parbox[t]{11cm}{
                            1. \studentone \\
                            2. \studenttwo \\
                            3. \studentthree \\
                         } \\
    Mata Kuliah    & : & \course \\
    Tugas          & : & \assignment \\
    Dosen Pengampu & : & \lecturerA \\
    Tanggal        & : & \tanggal
\end{tabular} \\[-0.1cm]
\rule{\textwidth}{1pt} % Garis bawah tebal
\begin{center}
\end{center}

\begin{center}
    \Large{\textbf{IMPLEMENTASI GAME SHADOW BOXING INTERAKTIF}} \\
    \Large{\textbf{BERBASIS COMPUTER VISION MENGGUNAKAN MEDIAPIPE}}
    \vspace{0.3cm}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% BODY DOCUMENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Pendahuluan}

\subsection{Latar Belakang}
Perkembangan teknologi computer vision dan machine learning saat ini memungkinkan interaksi manusia dengan komputer menjadi lebih intuitif dan menarik. Salah satu aplikasi yang berkembang pesat adalah game interaktif berbasis deteksi gerakan real-time, di mana pengguna dapat berinteraksi dengan sistem menggunakan gerakan tubuh tanpa memerlukan controller fisik.

Shadow boxing adalah teknik latihan tinju yang dilakukan tanpa lawan, di mana praktisi melakukan gerakan tinju di udara untuk melatih teknik, kecepatan, dan stamina. Dalam project ini, kami mengimplementasikan sebuah game boxing interaktif yang dapat mendeteksi gerakan tinju dan pertahanan pengguna secara real-time menggunakan teknologi MediaPipe. Game ini menciptakan pengalaman bermain yang immersive dengan sistem combat phase-based, difficulty levels, dan feedback visual-audio yang responsif.

Game Shadow Boxing ini menerapkan konsep computer vision untuk deteksi fist punching, defense blocking, dan dodge mechanism. Sistem menggunakan MediaPipe untuk mendeteksi hand landmarks (21 titik per tangan), pose landmarks (33 titik tubuh), dan face mesh (468 titik wajah). Dengan deteksi multi-landmark ini, game dapat membedakan antara gerakan menyerang (fist punch) dan bertahan (fingertips covering eyes).

\subsection{Rumusan Masalah}
\begin{enumerate}
    \item Bagaimana mengimplementasikan sistem deteksi fist punching yang akurat menggunakan MediaPipe hand landmarks?
    \item Bagaimana merancang combat system dengan phase-based gameplay (player attack vs enemy attack)?
    \item Bagaimana mengimplementasikan sequential hitbox spawning dengan position-based placement dan exclusion zones?
    \item Bagaimana mengimplementasikan defense system yang dapat mendeteksi blocking dan dodging?
    \item Bagaimana merancang difficulty levels yang seimbang untuk berbagai tingkat pemain?
\end{enumerate}

\subsection{Tujuan}
\begin{enumerate}
    \item Mengimplementasikan game boxing interaktif dengan MediaPipe untuk deteksi gerakan real-time
    \item Mengembangkan combat system dengan phase management (player attack, enemy attack warning, enemy attack)
    \item Mengimplementasikan hitbox system dengan sequential spawning dan collision detection
    \item Mengimplementasikan defense system untuk blocking (fingertips near eyes) dan dodging (head movement)
    \item Merancang tiga difficulty levels (Easy, Medium, Hard) dengan parameter yang berbeda
    \item Mengintegrasikan audio system dengan LUFS normalization untuk consistent sound levels
\end{enumerate}

\subsection{Batasan Masalah}
\begin{enumerate}
    \item Program dikembangkan menggunakan bahasa Python 3.10+
    \item Input berupa video stream dari webcam real-time
    \item Deteksi gerakan dibatasi pada gerakan tinju dasar (JAB, CROSS, HOOK)
    \item Game mode: Player vs Enemy (single player)
    \item Jumlah ronde: 3 ronde dengan rest period
    \item Program berjalan pada kondisi pencahayaan yang memadai untuk deteksi MediaPipe optimal
    \item Resolution: 1280x720 pixels (720p)
\end{enumerate}

\section{Landasan Teori}

\subsection{MediaPipe Framework}
MediaPipe adalah framework open-source yang dikembangkan oleh Google untuk membangun pipeline pemrosesan media multimodal. Framework ini menyediakan berbagai solusi machine learning yang telah dilatih sebelumnya untuk berbagai task seperti pose estimation, hand tracking, face detection, dan lain-lain.

MediaPipe menggunakan model machine learning yang efisien dan dapat berjalan real-time bahkan pada device dengan spesifikasi menengah. Framework ini mendukung berbagai platform termasuk desktop, mobile, dan web, menjadikannya pilihan ideal untuk aplikasi computer vision interaktif.

\subsection{Hand Landmark Detection}
MediaPipe Hands dapat mendeteksi 21 landmark pada setiap tangan dengan presisi tinggi dalam kondisi real-time. Setiap landmark memiliki koordinat x, y, dan z yang merepresentasikan posisi dalam ruang 3D normalized (0.0 - 1.0).

Landmark yang paling penting untuk deteksi fist dalam game ini adalah:
\begin{itemize}
    \item \textbf{Landmark 0 (Wrist)}: Basis untuk menghitung posisi tangan
    \item \textbf{Landmark 8, 12, 16, 20}: Fingertips untuk deteksi fist dan defense
    \item \textbf{Landmark 9 (Middle Finger MCP)}: Palm center untuk distance calculation
\end{itemize}

\subsection{Pose Landmark Detection}
MediaPipe Pose dapat mendeteksi 33 landmark pada tubuh manusia dengan akurasi tinggi. Dalam konteks game shadow boxing, landmark yang relevan adalah:
\begin{itemize}
    \item \textbf{Landmarks 1-6}: Eye landmarks untuk defense detection
    \item \textbf{Landmarks 11-12}: Shoulders untuk exclusion zones
    \item \textbf{Landmarks 23-24}: Hips untuk body exclusion zones
\end{itemize}

\subsection{Face Mesh Detection}
MediaPipe Face Mesh mendeteksi 468 landmark pada wajah dengan detail tinggi. Dalam game ini, face mesh digunakan untuk:
\begin{itemize}
    \item Menentukan face bounding box untuk exclusion zone
    \item Deteksi target area untuk enemy attacks
    \item Dodge detection berdasarkan head movement
\end{itemize}

\subsection{Fist Detection Algorithm}
Deteksi fist menggunakan pendekatan geometrik dengan menganalisis:
\begin{enumerate}
    \item \textbf{Finger Angles}: Sudut antara tip, middle, dan base joint setiap jari. Jari tertekuk (fist) memiliki sudut < threshold (biasanya 90°)
    \item \textbf{Distance to Palm}: Jarak euclidean dari fingertips ke palm center (landmark 9). Fist memiliki distance < threshold
    \item \textbf{Combined Threshold}: Rata-rata angle < 90° AND rata-rata distance < 0.15 (normalized)
\end{enumerate}

Formula deteksi fist:
\begin{equation}
\text{is\_fist} = \left(\frac{1}{n}\sum_{i=1}^{n} \theta_i < \theta_{threshold}\right) \land \left(\frac{1}{n}\sum_{i=1}^{n} d_i < d_{threshold}\right)
\end{equation}

Di mana $\theta_i$ adalah sudut jari ke-i, $d_i$ adalah jarak fingertip ke palm, dan $n$ adalah jumlah jari (4, tidak termasuk thumb).

\section{Game Design dan Metodologi}

\subsection{Konsep Game}
Shadow Boxing adalah game boxing interaktif one-on-one combat antara player dan enemy AI. Game menggunakan phase-based combat system dengan pergantian antara player attack phase dan enemy attack phase. Player menyerang dengan memukul hitbox yang muncul secara sekuensial, sementara enemy menyerang dengan combo attacks yang harus diblock atau di-dodge oleh player.

\textbf{Game Loop:}
\begin{enumerate}
    \item \textbf{Main Menu}: Player memilih difficulty (Easy/Medium/Hard)
    \item \textbf{Round Start}: Splash screen "ROUND X"
    \item \textbf{Combat Phase}: Player dan enemy bergantian menyerang
    \item \textbf{Rest Period}: Jeda antar ronde (10 detik)
    \item \textbf{Game Over}: Tampil hasil akhir (Win/Lose)
\end{enumerate}

\subsection{Phase System}
Game menggunakan tiga phase utama yang bergantian:

\textbf{1. Player Attack Phase (3.0-3.5 detik)}
\begin{itemize}
    \item Player menyerang hitbox yang muncul secara sekuensial
    \item Sequential spawning: hitbox berikutnya spawn setelah hitbox sebelumnya dipukul
    \item Position-based: JAB spawn di kiri (0-50\% width), CROSS/HOOK spawn di kanan (50-100\% width)
    \item Damage berdasarkan difficulty dan punch type (random range)
\end{itemize}

\textbf{2. Enemy Attack Warning Phase (0.7-1.5 detik)}
\begin{itemize}
    \item Visual indicator menunjukkan posisi serangan enemy
    \item Warning time berbeda per difficulty (HARD=0.7s, MEDIUM=1.0s, EASY=1.5s)
    \item Player mempersiapkan defense (block atau dodge)
\end{itemize}

\textbf{3. Enemy Attack Phase}
\begin{itemize}
    \item Enemy melakukan 2-3 combo attacks berturut-turut
    \item Delay 400ms antar serangan dalam combo
    \item Target prioritas: Face detection, fallback ke pose landmarks 0-10
    \item Damage calculation: base × difficulty multiplier
\end{itemize}

\subsection{Combat Mechanics}

\textbf{Damage System:}

Player damage menggunakan random range per difficulty:
\begin{itemize}
    \item \textbf{EASY}: JAB(12-13), HOOK(12-14), CROSS(12-15)
    \item \textbf{MEDIUM}: JAB(8-10), HOOK(8-11), CROSS(8-12)
    \item \textbf{HARD}: JAB(5-6), HOOK(5-7), CROSS(5-8)
\end{itemize}

Last hit bonus: 1.1× multiplier untuk serangan terakhir dalam combo.

Enemy damage: Random 10-20 × difficulty multiplier (EASY=0.7×, MEDIUM=1.0×, HARD=1.3×)

\textbf{Defense Mechanisms:}
\begin{enumerate}
    \item \textbf{Block}: Fingertips (landmarks 8,12,16,20) dalam radius 150px dari eye area (pose landmarks 1-6) → Damage reduction 80\%
    \item \textbf{Dodge}: Head position keluar dari target area → 100\% avoid damage
\end{enumerate}

\textbf{Win Conditions:}
\begin{itemize}
    \item \textbf{Victory}: Health tertinggi setelah 3 ronde
    \item \textbf{Defeat}: Health mencapai 0 (KO)
    \item \textbf{Perfect Win}: Tidak menerima damage sama sekali
\end{itemize}

\subsection{Difficulty Levels}

\begin{table}[h]
\centering
\caption{Parameter Difficulty Levels}
\label{tab:difficulty}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Parameter} & \textbf{EASY} & \textbf{MEDIUM} & \textbf{HARD} \\ \hline
Enemy Cooldown & 3.0-5.0s & 2.0-3.5s & 1.5-2.5s \\ \hline
Damage Multiplier & 0.7× & 1.0× & 1.3× \\ \hline
Warning Time & 1.5s & 1.0s & 0.7s \\ \hline
Player Attack Time & 3.5s & 3.0s & 2.5s \\ \hline
\end{tabular}
\end{table}

\subsection{Arsitektur Sistem}
Sistem game menggunakan arsitektur modular dengan separation of concerns:

\begin{enumerate}
    \item \textbf{core/}: Config, constants, math utilities
    \item \textbf{systems/}: Vision, audio, render, input processing
    \item \textbf{entities/}: Player dan enemy state management
    \item \textbf{game/}: Game state, hitbox system, round manager
    \item \textbf{ui/}: Menu, HUD, overlays, result screen
    \item \textbf{assets/}: Fonts, sprites, audio (sfx \& music)
\end{enumerate}

\subsection{Teknologi dan Library yang Digunakan}

Project Shadow Boxing ini menggunakan beberapa library Python yang memiliki peran spesifik dalam implementasi sistem. Berikut adalah penjelasan detail mengenai setiap library yang digunakan beserta fungsinya:

\subsubsection{OpenCV (opencv-python 4.10.0.84)}
OpenCV (Open Source Computer Vision Library) merupakan library open-source untuk computer vision dan machine learning. Dalam project ini, OpenCV memiliki fungsi sebagai:
\begin{enumerate}
    \item Mengambil input video dari webcam secara real-time dengan resolusi 1280x720 pixels menggunakan \texttt{cv2.VideoCapture()}
    \item Melakukan konversi color space dari BGR ke RGB untuk kompatibilitas dengan MediaPipe menggunakan \texttt{cv2.cvtColor()}
    \item Menggambar shapes, text, dan overlay pada frame video seperti health bar, hitbox, dan visual effects dengan functions seperti \texttt{cv2.rectangle()}, \texttt{cv2.circle()}, \texttt{cv2.line()}
    \item Mirror effect untuk pengalaman yang lebih intuitif menggunakan \texttt{cv2.flip()}
    \item Menampilkan output video dalam window dengan frame rate 30 FPS (meskipun rendering utama menggunakan Pygame)
\end{enumerate}

\subsubsection{MediaPipe (mediapipe 0.10.14)}
MediaPipe adalah framework machine learning yang dikembangkan oleh Google untuk building perception pipelines. Framework ini menyediakan pre-trained models untuk berbagai computer vision tasks. Dalam project ini, MediaPipe digunakan untuk:

\textbf{MediaPipe Hands:}
\begin{enumerate}
    \item Mendeteksi hingga 21 hand landmarks pada setiap tangan (maksimum 2 tangan)
    \item Landmark detection untuk fist recognition untuk bagian wrist, fingertips, dan middle finger MCP
    \item Digunakan untuk Fist detection algorithm, punch type classification, dan defense blocking detection
\end{enumerate}

\textbf{MediaPipe Pose:}
\begin{enumerate}
    \item Mendeteksi 33 body landmarks untuk tracking posisi tubuh pemain
    \item Key landmarks pada bagian Eyes (1-6), shoulders (11-12), hips (23-24), dan knees (25-26)
    \item Digunakan untuk Body exclusion zones, eye position untuk defense detection, dan posture analysis
\end{enumerate}

\textbf{MediaPipe Face Mesh:}
\begin{enumerate}
    \item Mendeteksi 468 facial landmarks dengan detail tinggi
    \item Digunakan untuk Face bounding box calculation, target area untuk enemy attacks, face exclusion zone untuk hitbox placement
\end{enumerate}

\textbf{Real-time Processing:}
\begin{enumerate}
    \item Memproses semua deteksi hands, pose, dan face secara bersamaan dengan latency <50ms
\end{enumerate}

\subsubsection{NumPy (numpy 1.26.4)}
NumPy adalah library fundamental untuk scientific computing dalam Python. Dalam project ini Numpy berfungsi untuk:

\begin{enumerate}
    \item Menyimpan dan mengolah posisi landmark (titik-titik tangan dan tubuh) dalam bentuk array untuk pemrosesan yang lebih cepat
    \item Menghitung jarak antara dua titik menggunakan rumus Euclidean dengan fungsi \texttt{np.linalg.norm()} untuk mendeteksi kecepatan gerakan
    \item Menghitung jarak antara tangan pemain dengan hitbox untuk deteksi tabrakan
    \item Menghitung sudut tekukan jari untuk mengetahui apakah tangan sedang mengepal (fist)
    \item Menghitung arah dan lintasan gerakan pukulan berdasarkan perpindahan posisi tangan dari waktu ke waktu
    \item Menghitung rata-rata sudut jari dan rata-rata jarak ujung jari ke telapak tangan untuk algoritma deteksi kepalan tangan
    \item Melakukan perhitungan secara bersamaan (paralel) tanpa perlu menggunakan perulangan satu per satu, sehingga game dapat berjalan dengan lancar (real-time) di 25-30 FPS
\end{enumerate}

Contoh penggunaan dalam project:
\begin{lstlisting}[language=Python]
# Distance calculation
distance = np.sqrt((x2-x1)**2 + (y2-y1)**2)

# Average angle calculation untuk fist detection
avg_angle = np.mean(angles) if angles else 180

# Array slicing untuk landmark filtering
eye_landmarks = pose_landmarks[1:7]
\end{lstlisting}

\subsubsection{Pygame (pygame 2.5.2)}
Pygame adalah library untuk pengembangan game dan multimedia applications. Dalam project ini Pygame berfungsi sebagai:

\textbf{Audio System Management:}
\begin{enumerate}
    \item {pygame.mixer} yaitu sistem audio dengan multi-channel support untuk simultaneous sound playback
    \item {Music Playback} untuk Background music dengan loop, volume control, dan fade effects
    \item {Sound Effects} berfungsi dalam Loading dan playing sound effects untuk punch, hit, KO, round transitions
    \item {Audio Channels} yang terdiri dari 8 channels untuk memastikan sounds tidak saling interrupt
    \item {LUFS Normalization}, dimana semua audio dinormalisasi ke -16 LUFS untuk consistent volume levels
\end{enumerate}

\textbf{Game Display \& Rendering:}
\begin{enumerate}
    \item Membuat tampilan game fullscreen dengan resolusi 1280x720 pixels (layar penuh tanpa border)
    \item Mengubah hasil tangkapan kamera dari format OpenCV menjadi format Pygame agar bisa ditampilkan di layar game
    \item Menggambar elemen-elemen HUD seperti bar health, timer waktu, dan penghitung combo di atas layar permainan
    \item Membuat overlay (lapisan) semi-transparan untuk menu dan efek transisi antar scene, sehingga latar belakang masih terlihat samar
\end{enumerate}

\textbf{Input Handling:}
\begin{enumerate}
    \item Mendeteksi tombol keyboard untuk kontrol game seperti SPACE (mulai game), ESC (pause/resume), Q (keluar), dan tombol panah (navigasi menu)
    \item Menggunakan fungsi \texttt{pygame.event.get()} untuk menangani banyak event (kejadian) yang terjadi dalam satu frame, seperti klik mouse atau penekanan tombol secara bersamaan
    \item Menggunakan \texttt{pygame.key.get\_pressed()} untuk mengecek apakah tombol sedang ditekan secara terus-menerus (tidak hanya saat pertama kali ditekan), berguna untuk pergerakan kontinu
\end{enumerate}


\subsubsection{Library Pendukung Lainnya}
Selain library utama di atas, project ini juga menggunakan built-in Python libraries:

\begin{enumerate}
    \item time
    \item random
    \item math
    \item os
\end{enumerate}

\subsubsection{Integrasi dan Dependency Management}
Semua library dikelola menggunakan \texttt{requirements.txt} dengan version pinning untuk reproducibility:

\begin{lstlisting}[language=bash]
opencv-python==4.10.0.84
mediapipe==0.10.14
numpy==1.26.4
pygame==2.5.2
\end{lstlisting}

Penggunaan version pinning memastikan kompatibilitas dan reproducibility saat instalasi dependencies.

\section{Implementasi}

\subsection{Struktur Project}
Project ini disusun dengan struktur modular yang mengikuti prinsip separation of concerns:

\begin{lstlisting}[language=bash, caption=Struktur Direktori Project,label={code:structure}]
shadow-boxing/
|-- main.py                    # Entry point & game loop
|-- requirements.txt           # Dependencies
|-- README.md                  # Documentation
|-- LICENSE                    # MIT License
|-- core/                      # Core utilities
|   |-- __init__.py
|   |-- config.py              # Game configuration
|   |-- constants.py           # Game constants
|   |-- math_utils.py          # Math helpers
|   |-- utils.py               # Font utilities
|-- systems/                   # Game systems
|   |-- __init__.py
|   |-- vision_system.py       # MediaPipe integration
|   |-- audio_system.py        # Sound manager
|   |-- render_system.py       # Graphics rendering
|   |-- input_processor.py     # Input detection
|-- entities/                  # Game entities
|   |-- __init__.py
|   |-- player.py              # Player state
|   |-- enemy.py               # Enemy AI
|-- game/                      # Game logic
|   |-- __init__.py
|   |-- game_state.py          # State management
|   |-- hit_box_system.py      # Hitbox generation
|   |-- combo_system.py        # Combo patterns
|   |-- enemy_attack_system.py # Enemy attack logic
|-- ui/                        # User interface
|   |-- __init__.py
|   |-- menu_system.py         # Main menu
|   |-- hud_renderer.py        # HUD elements
|   |-- fight_overlay.py       # Round transitions
|   |-- result_screen.py       # Results
|-- assets/                    # Game assets
|   |-- font/                  # PressStart2P.ttf
|   |-- sprites/               # Game sprites (PNG)
|   |-- wav/
|       |-- sfx/               # Sound effects (WAV)
|       |-- music/             # Background music (WAV)
|-- images/                    # Documentation images
    |-- screenshots/           # Game screenshots
    |-- demo/                  # Demo GIFs
\end{lstlisting}

\subsection{Vision System - MediaPipe Integration}
Kode \ref{code:vision} menunjukkan implementasi vision system yang mengintegrasikan MediaPipe Hands, Pose, dan Face Mesh.

\begin{lstlisting}[language=Python, caption=Vision System Implementation,label={code:vision}]
import cv2
import mediapipe as mp

class VisionSystem:
    def __init__(self, game_config):
        self.config = game_config
        # Initialize camera
        self.cap = cv2.VideoCapture(self.config.CAMERA_INDEX)
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)
        
        # Initialize MediaPipe solutions
        self.mp_hands = mp.solutions.hands
        self.mp_pose = mp.solutions.pose
        self.mp_face_mesh = mp.solutions.face_mesh
        
        # Configure Hands detector
        self.hands = self.mp_hands.Hands(
            static_image_mode=False,
            max_num_hands=2,
            min_detection_confidence=0.7,
            min_tracking_confidence=0.5
        )
        
        # Configure Pose detector
        self.pose = self.mp_pose.Pose(
            static_image_mode=False,
            model_complexity=0,  # Lightweight model
            min_detection_confidence=0.5,
            min_tracking_confidence=0.5
        )
        
        # Configure Face Mesh detector
        self.face_mesh = self.mp_face_mesh.FaceMesh(
            static_image_mode=False,
            max_num_faces=1,
            refine_landmarks=False,
            min_detection_confidence=0.5,
            min_tracking_confidence=0.5
        )
    
    def get_frame(self):
        """Get frame with all detections"""
        success, frame = self.cap.read()
        if not success:
            return None
        
        # Flip for mirror effect
        frame = cv2.flip(frame, 1)
        
        # Convert to RGB for MediaPipe
        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        
        # Process all detections
        hand_results = self.hands.process(rgb_frame)
        pose_results = self.pose.process(rgb_frame)
        face_results = self.face_mesh.process(rgb_frame)
        
        return {
            'frame': frame,
            'hands': hand_results,
            'pose': pose_results,
            'face': face_results
        }
\end{lstlisting}
\textbf {Penjelasan:} menunjukkan implementasi vision system yang mengintegrasikan MediaPipe Hands, Pose, dan Face Mesh. Kelas VisionSystem berfungsi sebagai bridge antara input kamera dan proses deteksi computer vision. Sistem ini menginisialisasi tiga modul MediaPipe secara bersamaan dengan konfigurasi yang disesuaikan untuk performa optimal: Hands detector untuk mendeteksi maksimal 2 tangan dengan 21 landmark per tangan, Pose detector dengan model ringan (complexity=0) untuk tracking 33 titik tubuh, dan Face Mesh untuk mendeteksi 468 landmark wajah. Fungsi get\_frame() mengambil frame dari webcam, melakukan mirror flip agar pengalaman lebih intuitif, mengonversi color space dari BGR ke RGB untuk kompatibilitas MediaPipe, kemudian memproses frame tersebut melalui ketiga detector secara simultan dan mengembalikan hasil deteksi beserta frame asli dalam bentuk dictionary untuk digunakan oleh sistem lain dalam game.

\subsection{Input Processor - Fist Detection}
Kode \ref{code:fist} menunjukkan algoritma deteksi fist menggunakan angle dan distance calculation.

\begin{lstlisting}[language=Python, caption=Fist Detection Algorithm,label={code:fist}]
import numpy as np
from core.math_utils import calculate_angle, distance

class InputProcessor:
    def __init__(self, game_config):
        self.config = game_config
        self.fist_angle_threshold = 90  # degrees
        self.fist_distance_threshold = 0.15  # normalized
    
    def _is_fist(self, landmarks):
        """Detect if hand is making a fist"""
        # Calculate angles for fingers (exclude thumb)
        angles = []
        for tip_id in [8, 12, 16, 20]:  # Index, middle, ring, pinky
            base_id = tip_id - 2
            mid_id = tip_id - 1
            
            angle = calculate_angle(
                (landmarks[tip_id].x, landmarks[tip_id].y),
                (landmarks[mid_id].x, landmarks[mid_id].y),
                (landmarks[base_id].x, landmarks[base_id].y)
            )
            angles.append(angle)
        
        avg_angle = np.mean(angles) if angles else 180
        
        # Calculate distances from fingertips to palm (landmark 9)
        palm = (landmarks[9].x, landmarks[9].y)
        distances = []
        for tip_id in [8, 12, 16, 20]:
            tip = (landmarks[tip_id].x, landmarks[tip_id].y)
            distances.append(distance(tip, palm))
        
        avg_dist = np.mean(distances) if distances else 1.0
        
        # Fist detected if both conditions met
        return (avg_angle < self.fist_angle_threshold and 
                avg_dist < self.fist_distance_threshold)
\end{lstlisting}
\textbf{Penjelasan:} Kelas InputProcessor mengimplementasikan algoritma deteksi kepalan tangan menggunakan dua metrik utama: sudut tekukan jari dan jarak ujung jari ke telapak tangan. Sistem menghitung sudut antara tiga titik pada setiap jari (ujung, tengah, pangkal) untuk keempat jari (telunjuk, tengah, manis, kelingking) menggunakan fungsi calculate\_angle(). Rata-rata sudut di bawah 90 derajat mengindikasikan jari tertekuk. Selanjutnya, sistem menghitung jarak Euclidean dari setiap ujung jari ke pusat telapak tangan (landmark 9). Jarak rata-rata di bawah 0.15 (dalam koordinat normalized) menunjukkan jari berada dekat dengan telapak. Kepalan tangan terdeteksi ketika kedua kondisi terpenuhi secara bersamaan, menghasilkan deteksi yang akurat dengan false positive rate rendah karena membutuhkan konfirmasi ganda dari geometri tangan.

\subsection{Hitbox System - Sequential Spawning}
Kode \ref{code:hitbox} menunjukkan implementasi sequential hitbox spawning dengan position-based placement dan exclusion zones.

\begin{lstlisting}[language=Python, caption=Hitbox Generation dengan Exclusion Zones,label={code:hitbox}]
import random
import math

class HitBoxSystem:
    def __init__(self, game_config):
        self.config = game_config
        self.hitbox_radius = 65
        self.active_hitboxes = []
        self.sequential_mode = True
    
    def generate_hitboxes(self, combo_sequence, face_bbox, 
                         pose_landmarks):
        """Generate sequential hitboxes dengan exclusion zones"""
        # Define face exclusion zone (expanded 100px)
        face_zone = None
        if face_bbox:
            fx, fy, fw, fh = face_bbox
            face_zone = {
                'x1': max(0, fx - 100),
                'y1': max(0, fy - 100),
                'x2': min(1280, fx + fw + 100),
                'y2': min(720, fy + fh + 100)
            }
        
        # Define body exclusion zones (shoulders & hips)
        body_zones = []
        if pose_landmarks:
            # Landmarks 11,12 (shoulders), 23,24 (hips)
            for idx in [11, 12, 23, 24]:
                if idx < len(pose_landmarks):
                    lm = pose_landmarks[idx]
                    x = int(lm.x * 1280)
                    y = int(lm.y * 720)
                    body_zones.append({
                        'cx': x, 'cy': y, 'radius': 120
                    })
        
        # Generate hitboxes
        for i, punch_type in enumerate(combo_sequence):
            placed = False
            attempts = 0
            
            while not placed and attempts < 100:
                attempts += 1
                
                # Position-based placement
                if punch_type == "JAB":
                    # Left side (0-50% width)
                    x = random.randint(50, 640 - 130)
                else:  # CROSS or HOOK
                    # Right side (50-100% width)
                    x = random.randint(640, 1280 - 180)
                
                y = random.randint(200, 720 - 180)
                center_x = x + 65
                center_y = y + 65
                
                # Check exclusion zones
                if self._in_exclusion_zone(center_x, center_y, 
                                          face_zone, body_zones):
                    continue
                
                # Check overlap with existing hitboxes
                if self._check_overlap(center_x, center_y):
                    continue
                
                # Place hitbox
                self.active_hitboxes.append({
                    'id': i,
                    'x': x, 'y': y,
                    'center_x': center_x,
                    'center_y': center_y,
                    'punch_type': punch_type,
                    'active': (i == 0)  # Only first active
                })
                placed = True
\end{lstlisting}
\textbf{Penjelasan:} Kelas HitBoxSystem mengelola munculnya target pukulan secara berurutan dengan mempertimbangkan zona terlarang dan penempatan berbasis posisi. Sistem membuat dua jenis exclusion zone, yaitu zona wajah yang diperluas 100 piksel dari bounding box wajah untuk menghindari target menutupi area wajah pemain, dan zona tubuh dengan radius 120 piksel di sekitar bahu (landmarks 11-12) dan pinggul (landmarks 23-24) untuk menghindari area tubuh natural. Setiap target ditempatkan berdasarkan jenis pukulan, dengan JAB spawn di sisi kiri layar (0-50\% lebar) dan CROSS/HOOK di sisi kanan (50-100\% lebar). Sistem melakukan hingga 100 percobaan untuk menemukan posisi valid yang tidak bertabrakan dengan exclusion zones atau target lain yang sudah ada. Target dibuat dalam mode sequential di mana hanya target pertama yang aktif, dan target berikutnya akan diaktifkan setelah target sebelumnya dipukul, menciptakan gameplay yang terstruktur dan progressive.

\subsection{Defense System}
Kode \ref{code:defense} menunjukkan implementasi defense detection menggunakan fingertips proximity ke eye area.

\begin{lstlisting}[language=Python, caption=Defense Detection Algorithm,label={code:defense}]
class InputProcessor:
    def _check_defense(self, game_state):
        """Check defense: fingertips near eye area"""
        # Get eye landmarks (pose landmarks 1-6)
        eye_landmarks_idx = [1, 2, 3, 4, 5, 6]
        eye_positions = []
        
        for idx in eye_landmarks_idx:
            if idx < len(game_state.pose_landmarks):
                lm = game_state.pose_landmarks[idx]
                eye_x = int(lm.x * 1280)
                eye_y = int(lm.y * 720)
                eye_positions.append((eye_x, eye_y))
        
        if not eye_positions:
            return
        
        # Calculate average eye position
        avg_eye_x = sum(p[0] for p in eye_positions) // len(eye_positions)
        avg_eye_y = sum(p[1] for p in eye_positions) // len(eye_positions)
        
        # Defense threshold: 150px radius
        defense_threshold = 150
        
        # Check fingertips (landmarks 8,12,16,20) from both hands
        defending_hands = 0
        
        for hand_state in [self.hand_states['Left'], 
                          self.hand_states['Right']]:
            if hand_state['fingertips']:
                for tip_pos in hand_state['fingertips']:
                    dx = tip_pos[0] - avg_eye_x
                    dy = tip_pos[1] - avg_eye_y
                    dist = (dx**2 + dy**2)**0.5
                    
                    if dist < defense_threshold:
                        defending_hands += 1
                        break
        
        # Defense active if at least one hand covering
        self.defense_active = (defending_hands >= 1)
\end{lstlisting}
\textbf{Penjelasan:} Metode \_check\_defense() mengimplementasikan sistem deteksi pertahanan pemain dengan mengukur kedekatan ujung jari ke area mata. Sistem pertama-tama mengumpulkan posisi eye landmarks (pose landmarks 1-6) dan menghitung rata-rata posisi mata sebagai titik referensi. Dengan threshold jarak 150 piksel, sistem memeriksa apakah ujung jari dari kedua tangan (landmarks 8, 12, 16, 20) berada dalam radius ini dari posisi rata-rata mata. Perhitungan menggunakan jarak Euclidean antara setiap ujung jari dan posisi mata, dengan formula $(dx^2 + dy^2)^{0.5}$. Pertahanan dianggap aktif ketika minimal satu tangan memiliki ujung jari yang berada dalam threshold, yang mengindikasikan pemain sedang menutup wajah untuk blocking. Pendekatan ini lebih akurat dibanding palm detection karena fokus pada fingertips yang secara natural berada dekat mata saat pemain melakukan blocking stance, menghasilkan false positive rate di bawah 5\%.
\section{Hasil dan Pembahasan}

\subsection{Hasil Implementasi}
Game Shadow Boxing berhasil diimplementasikan dengan fitur-fitur lengkap:

\begin{enumerate}
\item \textbf{Core Features:}

Game ini menggunakan teknologi MediaPipe untuk mendeteksi gerakan tangan, tubuh, dan wajah pemain secara real-time (langsung tanpa jeda). Sistem pertarungan dirancang dengan tiga fase yang bergantian: fase pemain menyerang (Player Attack), fase peringatan serangan musuh (Enemy Attack Warning), dan fase musuh menyerang (Enemy Attack). Target pukulan (hitbox) muncul secara berurutan satu per satu, di mana target berikutnya baru muncul setelah target sebelumnya berhasil dipukul (hit-to-spawn mechanism).

Pemain dapat memilih tiga tingkat kesulitan (mudah, sedang, sulit) dengan parameter yang berbeda-beda untuk setiap level. Setiap permainan terdiri dari 3 ronde pertarungan dengan periode istirahat di antara ronde. Untuk bertahan dari serangan musuh, pemain bisa melakukan blocking (menutup wajah dengan tangan) atau dodging (menghindar dengan menggerakkan kepala). Seluruh suara efek game telah dinormalisasi ke standar -16 LUFS sehingga volume suara konsisten dan tidak ada yang terlalu keras atau pelan.

\item \textbf{Game Mechanics:}

Sistem mendeteksi kepalan tangan (fist) dengan menganalisis dua hal: sudut tekukan jari dan jarak ujung jari ke telapak tangan. Ketika pemain memukul, sistem menghitung apakah tangan mengenai target menggunakan perhitungan jarak berbentuk lingkaran. Target pukulan (hitbox) ditempatkan berdasarkan jenis pukulan: JAB muncul di sisi kiri layar, sedangkan CROSS dan HOOK muncul di sisi kanan.

Untuk memastikan target tidak menutupi wajah atau tubuh pemain, sistem membuat zona terlarang di area wajah (100 piksel) dan bagian tubuh penting seperti bahu dan pinggul (120 piksel). Jika target gagal ditempatkan karena zona terlarang terlalu banyak, sistem memiliki tiga tingkat cadangan: pertama dengan aturan lengkap, kedua dengan aturan yang lebih longgar, dan ketiga memaksa target muncul dengan aturan minimal. Pertahanan pemain dideteksi ketika ujung jari berada dalam jarak 150 piksel dari area mata. Damage yang diberikan bervariasi secara acak tergantung tingkat kesulitan dan jenis pukulan, dengan bonus 1.1× untuk pukulan terakhir dalam kombo.

\item \textbf{User Interface:}

Antarmuka game dimulai dengan menu utama yang memungkinkan pemain memilih tingkat kesulitan sebelum bermain. Selama pertarungan berlangsung, layar menampilkan HUD (Heads-Up Display) yang berisi bar kesehatan untuk melihat sisa nyawa pemain dan musuh, timer untuk menghitung waktu ronde, penghitung kombo untuk melacak jumlah pukulan beruntun, dan indikator fase untuk menunjukkan giliran siapa yang sedang menyerang. Saat transisi antar ronde, muncul overlay bertuliskan "ROUND X" atau "FIGHT!" untuk memberi jeda visual. Setelah pertandingan selesai, layar hasil menampilkan statistik lengkap termasuk jumlah pukulan yang berhasil mengenai target (hits landed) dan total damage yang diberikan ke musuh, sehingga pemain dapat melihat performa mereka.

\end{enumerate}
\subsection{Technical Achievements}

\begin{enumerate}
\item \textbf{Hitbox Generation Success Rate: 100\%}

Sistem berhasil mencapai tingkat keberhasilan 100\% dalam menempatkan target pukulan (hitbox) dengan menggunakan mekanisme tiga tingkat cadangan. Tingkat pertama menggunakan aturan lengkap dengan zona terlarang penuh dan jarak minimal 30 piksel antar target. Jika gagal, tingkat kedua mencoba dengan aturan yang lebih longgar: zona wajah diperkecil menjadi 50 piksel dan zona tubuh dihilangkan, dengan jarak minimal 20 piksel. Jika masih gagal, tingkat ketiga memaksa target muncul dengan pemeriksaan minimal untuk memastikan game tetap bisa dimainkan.

Sebelum sistem cadangan ini diterapkan, tingkat keberhasilan hanya sekitar 70\% untuk kombinasi 3 pukulan atau lebih, artinya sering kali target tidak bisa muncul dan permainan terganggu. Setelah implementasi sistem tiga tingkat ini, semua kombinasi pukulan (dari 2 hingga 4 target) berhasil ditempatkan 100\%, sehingga game selalu berjalan lancar tanpa ada target yang gagal muncul.

\item \textbf{Defense Detection Accuracy}

Defense system menggunakan fingertips (bukan palm) untuk mengurangi false positives:
\begin{itemize}
    \item \textbf{Block detection}: Fingertips dalam 150px dari eye area
    \item \textbf{Damage reduction}: 80\% (20\% damage diterima)
    \item \textbf{False positive rate}: < 5\% (berdasarkan testing manual)
\end{itemize}

\item \textbf{Performance Optimization}

\begin{table}[h]
\centering
\caption{Performance Metrics}
\label{tab:performance}
\begin{tabular}{|l|c|}
\hline
\textbf{Metric} & \textbf{Value} \\ \hline
Average FPS & 25-30 fps \\ \hline
Detection Latency & <50ms \\ \hline
Input-to-Effect Latency & <100ms \\ \hline
Memory Usage & ~500MB \\ \hline
\end{tabular}
\end{table}

\end{enumerate}

\subsection{Game Balance Analysis}

Testing dilakukan pada tiga difficulty levels:

\begin{table}[h]
\centering
\caption{Difficulty Balance Testing}
\label{tab:balance}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Metric} & \textbf{EASY} & \textbf{MEDIUM} & \textbf{HARD} \\ \hline
Avg Hits to KO Enemy & 7-8 & 10-12 & 15-18 \\ \hline
Avg Time per Round & 30-40s & 40-50s & 50-60s \\ \hline
Player Damage Taken & 20-30 & 40-60 & 70-90 \\ \hline
Win Rate (Casual) & ~90\% & ~60\% & ~30\% \\ \hline
\end{tabular}
\end{table}

\textbf{Observations:}
\begin{itemize}
    \item \textbf{EASY}: Cocok untuk pemula, enemy mudah di-KO dengan damage tinggi (12-15)
    \item \textbf{MEDIUM}: Balanced gameplay, membutuhkan strategi defense
    \item \textbf{HARD}: Challenging, membutuhkan timing dan defense yang baik
\end{itemize}

\subsection{Tantangan dan Solusi}

\textbf{Challenge 1: Hitbox Generation Failures}

\textit{Problem:} Sequential hitboxes gagal generate karena constraint terlalu ketat (face zone, body zones, overlap, last position). Later hitboxes (index 2-3) sering gagal mencari posisi valid.

\textit{Solution:} 
\begin{enumerate}
    \item Reset attempts counter per-hitbox (bukan global)
    \item Implementasi 3-tier fallback dengan relaxed constraints
    \item Force placement sebagai last resort
\end{enumerate}

\textit{Result:} Hitbox generation success rate meningkat dari ~70\% menjadi 100\%.

\textbf{Challenge 2: Defense False Positives}

\textit{Problem:} Defense terdeteksi saat tangan tidak benar-benar menutup wajah (palm detection terlalu luas).

\textit{Solution:}
\begin{enumerate}
    \item Ganti dari palm detection menjadi fingertips detection
    \item Gunakan landmarks 8,12,16,20 (fingertips only)
    \item Threshold 150px dari average eye position
\end{enumerate}

\textit{Result:} False positive rate turun dari ~20\% menjadi <5\%.

\textbf{Challenge 3: Body Landmark Collisions}

\textit{Problem:} Hitbox sering spawn di area di mana tangan naturally idle (dekat shoulders, hips).

\textit{Solution:}
\begin{enumerate}
    \item Tambahkan body exclusion zones
    \item Landmarks 11,12 (shoulders), 23,24 (hips)
    \item Radius 120px per landmark
\end{enumerate}

\textit{Result:} Hitbox placement menjadi lebih natural dan comfortable untuk dipukul.

\textbf{Challenge 4: Performance dengan Multiple MediaPipe Models}

\textit{Problem:} Running Hands + Pose + Face Mesh simultaneously menurunkan FPS drastis (dari 30fps ke 15fps).

\textit{Solution:}
\begin{enumerate}
    \item Gunakan model\_complexity=0 untuk Pose (lightweight)
    \item Disable refine\_landmarks untuk Face Mesh
    \item Set buffer size=1 untuk camera capture
\end{enumerate}

\textit{Result:} FPS stabil di 25-30fps dengan all detections active.

\subsection{Instalasi dan Cara Penggunaan Program}

\subsubsection{Persyaratan Sistem}
Sebelum menjalankan game Shadow Boxing, pastikan sistem memenuhi persyaratan berikut:
\begin{itemize}
    \item \textbf{Sistem Operasi}: Windows 10/11, Linux (Ubuntu 20.04+), atau macOS 10.15+
    \item \textbf{Python}: Versi 3.10 atau lebih baru
    \item \textbf{Webcam}: Resolusi minimal 720p dengan frame rate 30 FPS
    \item \textbf{RAM}: Minimal 4GB (direkomendasikan 8GB)
    \item \textbf{Storage}: Minimal 500MB ruang kosong
    \item \textbf{Pencahayaan}: Ruangan dengan pencahayaan yang cukup untuk deteksi MediaPipe optimal
\end{itemize}

\subsubsection{Instalasi Manual}
Untuk instalasi manual, ikuti langkah-langkah berikut:

\textbf{1. Clone Repository}
\begin{lstlisting}[language=bash]
git clone https://github.com/Aziz097/shadow-boxing.git
cd shadow-boxing
\end{lstlisting}

\textbf{2. Install Dependencies}
\begin{lstlisting}[language=bash]
pip install -r requirements.txt
\end{lstlisting}

File \texttt{requirements.txt} berisi:
\begin{lstlisting}[language=bash]
opencv-python==4.10.0.84
mediapipe==0.10.14
numpy==1.26.4
pygame==2.5.2
\end{lstlisting}

\textbf{3. Jalankan Game}
\begin{lstlisting}[language=bash]
python -u main.py
\end{lstlisting}

\subsubsection{Virtual Environment (Recommended)}
Disarankan menggunakan virtual environment untuk menghindari konflik dependencies:

\textbf{Windows:}
\begin{lstlisting}[language=bash]
python -m venv venv
venv\Scripts\activate
pip install -r requirements.txt
python main.py
\end{lstlisting}

\textbf{Linux/macOS:}
\begin{lstlisting}[language=bash]
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
python main.py
\end{lstlisting}

\textbf{Catatan Penting:} MediaPipe 0.10.14 memerlukan Python 3.10. Pastikan menggunakan Python versi yang sesuai.

\subsubsection{Cara Penggunaan}

\textbf{1. Main Menu}
\begin{enumerate}
    \item Setelah game dimulai, pemain akan melihat main menu dengan latar belakang feed kamera
    \item Gunakan tombol \textbf{Arrow Up/Down} untuk navigasi menu
    \item Pilih tingkat kesulitan: \textbf{Easy}, \textbf{Medium}, atau \textbf{Hard}
    \item Tekan \textbf{ENTER} untuk memulai game
    \item Tekan \textbf{Q} untuk keluar
\end{enumerate}

\textbf{2. Gameplay}
\begin{enumerate}
    \item \textbf{Player Attack Phase}: 
    \begin{enumerate}
        \item Target pukulan (hitbox) akan muncul di layar
        \item Kepalkan tangan dan pukul target yang muncul
        \item Target baru akan muncul setelah target sebelumnya dipukul
        \item Waktu terbatas (2.5-3.5 detik tergantung difficulty)
    \end{enumerate}
    \item \textbf{Enemy Attack Phase}:
    \begin{enumerate}
        \item Peringatan visual akan muncul sebelum enemy menyerang
        \item \textbf{Block}: Tutup wajah dengan kedua tangan untuk mengurangi damage 80\%
        \item \textbf{Dodge}: Gerakkan kepala keluar dari area target untuk menghindari damage 100\%
    \end{enumerate}
    \item \textbf{Kontrol Game}:
    \begin{enumerate}
        \item \textbf{Q}: Keluar ke menu utama
    \end{enumerate}
\end{enumerate}

\textbf{3. Tips Bermain}
\begin{enumerate}
    \item Pastikan posisi badan menghadap kamera dengan pencahayaan yang cukup
    \item Berdirilah pada jarak 1-2 meter dari kamera
    \item Untuk deteksi fist yang optimal, kepalkan tangan dengan kuat
    \item Perhatikan indikator fase untuk mengetahui kapan giliran menyerang atau bertahan
    \item Manfaatkan warning phase untuk mempersiapkan defense
    \item Kombinasi block dan dodge untuk meminimalkan damage yang diterima
\end{enumerate}

\section{Kesimpulan dan Saran}

\subsection{Kesimpulan}
\begin{enumerate}
    \item Game Shadow Boxing interaktif berhasil diimplementasikan dengan memanfaatkan MediaPipe untuk deteksi real-time hand, pose, dan face landmarks
    \item Combat system dengan phase-based gameplay (player attack vs enemy attack) berfungsi dengan baik dan menciptakan gameplay yang engaging
    \item Sequential hitbox spawning dengan position-based placement dan exclusion zones berhasil memberikan pengalaman gameplay yang natural
    \item Defense system dengan fingertips proximity detection mampu mendeteksi blocking dengan akurasi tinggi (false positive <5\%)
    \item Tiga difficulty levels (Easy, Medium, Hard) telah dibalance dengan baik untuk berbagai tingkat pemain
    \item Hitbox generation dengan 3-tier fallback mechanism mencapai success rate 100\%
    \item Performance game stabil di 25-30 FPS dengan multiple MediaPipe models berjalan simultaneously
    \item Audio system dengan LUFS normalization memberikan consistent sound levels untuk better player experience
\end{enumerate}

\subsection{Saran Pengembangan}
\begin{enumerate}
    \item \textbf{Machine Learning Enhancement}: Implementasi ML model untuk klasifikasi punch type yang lebih akurat berdasarkan trajectory dan velocity patterns
    \item \textbf{Combo Detection Advanced}: Mendeteksi player combo patterns dan memberikan bonus damage untuk execution yang baik
    \item \textbf{Training Mode}: Mode latihan dengan feedback untuk kualitas teknik (punch speed, form, timing)
    \item \textbf{Performance Optimization}: 
    \begin{itemize}
        \item Multi-threading untuk MediaPipe processing
        \item GPU acceleration untuk pose estimation
        \item Adaptive resolution berdasarkan device capability
    \end{itemize}
    \item \textbf{Multiplayer Mode}: Local co-op atau online multiplayer dengan synchronization
    \item \textbf{Advanced AI}: 
    \begin{itemize}
        \item Adaptive difficulty berdasarkan player skill
        \item Pattern recognition untuk counter player strategies
        \item Multiple enemy types dengan attack patterns berbeda
    \end{itemize}
    \item \textbf{Gameplay Features}:
    \begin{itemize}
        \item Replay system dengan slow motion
        \item Achievement dan progression system
        \item Character customization
        \item Tournament mode dengan bracket
    \end{itemize}
    \item \textbf{Cross-Platform}: Port ke mobile (Android/iOS) dan web (WebAssembly)
    \item \textbf{Accessibility}: 
    \begin{itemize}
        \item Configurable MediaPipe confidence thresholds
        \item Adjustable difficulty parameters
        \item Colorblind-friendly UI
    \end{itemize}
\end{enumerate}

\textbf{Kolaborasi Tim:}
\begin{enumerate}
    \item \textbf{Brainstorming}: Semua anggota berpartisipasi dalam design decisions dan problem solving
    \item \textbf{Code Review}: Cross-review untuk maintain code quality
    \item \textbf{Testing}: Kolaboratif testing untuk identify bugs dan balance issues
    \item \textbf{Documentation}: Shared responsibility untuk README dan technical documentation
\end{enumerate}

\newpage
\section{Development Logbook}
Project dikembangkan secara iteratif dengan milestone-milestone berikut:
\begin{table}[h]
\centering
\caption{Timeline Pengembangan}
\label{tab:logbook}
\small
\begin{tabular}{|p{2.5cm}|p{4cm}|p{7cm}|}
\hline
\textbf{Tanggal} & \textbf{Kegiatan} & \textbf{Hasil / Progress} \\ \hline
\textbf{10/28/2024} & Project Initialization & Repository setup, team coordination, scope definition \\ \hline
\textbf{11/09/2024} & Asset Selection \& Flow Design & Fixed assets (sound, sprites, font), game flow wireframe, UI mockups \\ \hline
\textbf{11/10/2024} & Core Implementation & \textbf{Systems:} MediaPipe integration, audio manager, visual effects. \textbf{Mechanics:} Punch detection, defense system, hitbox generation, combo patterns. \textbf{UI:} Menu system, HUD renderer, transitions. \textbf{Features:} 3-level difficulty, text caching, fullscreen support \\ \hline
\textbf{11/17/2024} & Audio Processing \& Polish & \textbf{Audio:} WAV conversion (44100 Hz, mono, 16-bit PCM), LUFS normalization (-16 dB). \textbf{UI Polish:} Font size adjustments, menu alignment fixes. \textbf{Automation:} Launcher scripts (bat/sh), auto dependency check \\ \hline
\textbf{11/18/2024} & Code Refactoring & Flatten folder structure, remove dead code, module docstrings, import optimization, clean code principles (SRP, DRY), clear naming conventions \\ \hline
\textbf{11/24/2024} & Combat System Overhaul & \textbf{Major Changes:} Timing-based → sequence system, hit-to-spawn mechanism, immediate damage, last hit 1.1× bonus, player attack 4s. \textbf{Bug Fixes:} Phase transition, sequential hitbox consistency, phantom outline rendering \\ \hline
\textbf{11/25/2024} & Advanced Features \& Bug Fixes & \textbf{Improvements:} Hit detection expanded (landmarks 3-20), position-based hitbox, body exclusion zones, attack duration limit (4s max). \textbf{Bug Fixes:} Hitbox generation failures, 3-tier fallback, per-hitbox counter, collision spacing (50px → 30px). \textbf{Cleanup:} Unused variables removed, config audit, debug logging \\ \hline
\end{tabular}
\end{table}

\newpage
\section{Pembagian Tugas}
\begin{table}[h]
\centering
\caption{Pembagian Tugas Anggota Kelompok}
\label{tab:pembagian-tugas}
\begin{tabular}{|l|p{9cm}|}
\hline
\textbf{Nama} & \textbf{Kontribusi} \\ \hline
\textbf{Aziz Kurniawan} & Lead Developer: Game logic implementation, MediaPipe integration dan tuning, hitbox system development, combat mechanics, sequential spawning algorithm, bug fixing dan optimization, quality assurance testing \\ \hline
\textbf{Harisya Miranti} & UI/UX Designer: Visual effects implementation, HUD renderer design, menu system, fight overlay animations, sprite integration, asset creation dan curation, user interface design, testing dan user experience evaluation \\ \hline
\textbf{Muhammad Yusuf} & Systems Architect: MediaPipe integration, game flow architecture, audio system implementation, vision system optimization, input processing, systems integration, documentation, laporan dan presentasi \\ \hline
\end{tabular}
\end{table}

\newpage
\section*{Referensi}

\begin{enumerate}
    \item Lugaresi, C., Tang, J., Nash, H., McClanahan, C., Uboweja, E., Hays, M., Zhang, F., Chang, C.-L., Yong, M. G., Lee, J., Chang, W.-T., Hua, W., Georg, M., \& Grundmann, M. (2019). \textit{MediaPipe: A Framework for Building Perception Pipelines}. arXiv preprint arXiv:1906.08172. \url{https://arxiv.org/abs/1906.08172}
    \item Zhang, F., Bazarevsky, V., Vakunov, A., Tkachenka, A., Sung, G., Chang, C.-L., \& Grundmann, M. (2020). \textit{MediaPipe Hands: On-device Real-time Hand Tracking}. arXiv preprint arXiv:2006.10214. \url{https://arxiv.org/abs/2006.10214}
    \item Bazarevsky, V., Grishchenko, I., Raveendran, K., Zhu, T., Zhang, F., \& Grundmann, M. (2020). \textit{BlazePose: On-device Real-time Body Pose Tracking}. arXiv preprint arXiv:2006.10204. \url{https://arxiv.org/abs/2006.10204}
    \item OpenCV Team. (2024). \textit{OpenCV: Open Source Computer Vision Library}. \url{https://opencv.org/}
    \item Harris, C. R., Millman, K. J., van der Walt, S. J., Gommers, R., Virtanen, P., Cournapeau, D., Wieser, E., Taylor, J., Berg, S., Smith, N. J., Kern, R., Picus, M., Hoyer, S., van Kerkwijk, M. H., Brett, M., Haldane, A., del Río, J. F., Wiebe, M., Peterson, P., Gérard-Marchant, P., Sheppard, K., Reddy, T., Weckesser, W., Abbasi, H., Gohlke, C., \& Oliphant, T. E. (2020). \textit{Array programming with NumPy}. Nature, 585(7825), 357-362. \url{https://doi.org/10.1038/s41586-020-2649-2}
    \item Pygame Community. (2024). \textit{Pygame: Python Game Development}. \url{https://www.pygame.org/}
    \item Pisharady, P. K., \& Saerbeck, M. (2015). \textit{Recent methods and databases in vision-based hand gesture recognition: A review}. Computer Vision and Image Understanding, 141, 152-165. \url{https://doi.org/10.1016/j.cviu.2015.08.004}
    \item Rautaray, S. S., \& Agrawal, A. (2015). \textit{Vision based hand gesture recognition for human computer interaction: a survey}. Artificial Intelligence Review, 43(1), 1-54. doi:10.1007/s10462-012-9356-9
    \item Maggioni, E., Cobden, R., \& Obrist, M. (2020). \textit{Design and development challenges in multimodal gesture recognition}. ACM Transactions on Computer-Human Interaction (TOCHI), 27(4), 1-43. \url{https://doi.org/10.1145/3397869}
\end{enumerate}

\newpage
\appendix
\section{Lampiran: Screenshot Game}

Berikut adalah screenshot dari berbagai tampilan game Shadow Boxing:

\begin{figure}[h!]
\centering
\includegraphics[width=0.85\textwidth]{Figure/home.png}
\caption{Tampilan Menu Utama - Player dapat memilih opsi Start Game, Difficulty, Help, atau Quit}
\label{fig:home}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=0.85\textwidth]{Figure/select difficulty.png}
\caption{Tampilan Pemilihan Difficulty - Tersedia tiga tingkat kesulitan: Easy, Medium, dan Hard}
\label{fig:difficulty}
\end{figure}

\newpage
\begin{figure}[h!]
\centering
\includegraphics[width=0.85\textwidth]{Figure/ingame.png}
\caption{Tampilan Gameplay - Menampilkan HUD dengan health bar, timer, combo counter, dan hitbox target}
\label{fig:ingame}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=0.85\textwidth]{Figure/rest.png}
\caption{Tampilan Rest Period - Jeda antar ronde dengan countdown timer}
\label{fig:rest}
\end{figure}

\newpage
\begin{figure}[h!]
\centering
\includegraphics[width=0.85\textwidth]{Figure/ko.png}
\caption{Tampilan KO Effect - Efek visual saat salah satu pihak kalah KO}
\label{fig:ko}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=0.85\textwidth]{Figure/result.png}
\caption{Tampilan Result Screen - Menampilkan hasil akhir pertandingan dengan skor}
\label{fig:result}
\end{figure}

\end{document}